package chainsaw.instance{		import chainsaw.math.*;	import chainsaw.geometry.geometry;	import chainsaw.geometry.polygon;	import chainsaw.scene.scene;		public class instance extends geometry	{		public var _pointer	:		Number;				public function instance(scn:scene,p:Number,t:Array):void		{			_pointer = p;//give it the string to what it is using				_ttm.translate(t[0],t[1],t[2]);//trace("####a:"+this._ttm._n11+"	b:"+this._ttm._n12+"	c:"+this._ttm._n13+"	d:"+this._ttm._n14+"	e:"+this._ttm._n21+"	f:"+this._ttm._n22+"	g:"+this._ttm._n23+"	h:"+this._ttm._n24+"	i:"+this._ttm._n31+"	j:"+this._ttm._n32+"	k:"+this._ttm._n33+"	l:"+this._ttm._n34+"	m:"+this._ttm._n41+"	n:"+this._ttm._n42+"	o:"+this._ttm._n43+"	p:"+this._ttm._n44)			_rnm.mult_3matrix_4matrix(_trm,_ttm);			var ref = scn._objects[p]._obj;							for(var i in ref){//for each obj in obj objct array				_obj.push( new geometry() );			}		}				public function render_collect( cam ):Array		{			var draw_data:Array =  new Array();						for(var obj in _obj)//for each peice of geomoetry in obj			{					var nst_geo	:	geometry	=	_obj[obj];//the instanced geometry				var ref_geo	:	geometry 	= 	cam._scene._objects[_pointer]._obj[obj];//geo._obj[obj];//the or object geometry				var newttm 					= 	new matrix4();								nst_geo = new geometry();				nst_geo._cen.copy(ref_geo._cen);//rest the cen				nst_geo._rad = ref_geo._rad;//rest the rad				nst_geo._backface_cull = cam._scene._objects[_pointer]._backface_cull;				newttm.tform_4matrix( _rnm, cam._rnm );//multiply camera into transforms				nst_geo._cen.multiply_m4( newttm );//translate center vert //ref_geo._cen				nst_geo._intersect = cam.frustum_check( nst_geo );								if(nst_geo._intersect != -1)//if the object is inside the frustum									{						var newtnm = new matrix3();					var newnew = new matrix4();										newtnm.mult_3matrix( _trm, cam._trm );//multiply camera into normals transforms					newnew.mult_4matrix( newttm, cam._rm );//multiply by render matrix this is my final render  matrix										for (var p in ref_geo._pointlist)//loop through points					{						nst_geo._pointlist[ p ] = new vector( ref_geo._pointlist[ p ]._x, ref_geo._pointlist[ p ]._y, ref_geo._pointlist[ p ]._z);						nst_geo._pointlist[ p ].multiply_m4( newttm );					}					for (var ply in ref_geo._poly)//go through the polygons						{						nst_geo.addpoly(  [] , '', false);//make a new polygon, set it to false for not calculating normal						nst_geo._poly[ply].duplicate( ref_geo._poly[ply] );//now just dup values						if( ! nst_geo._poly[ply].cull( cam._camtoface, newtnm, nst_geo ) )// i have to use reference because the new stuff is tranlated now						{							var draw_poly = true;							if(nst_geo._intersect==0)//if we are intersectin frustum vlip polygon to plane							{									var new_poly = nst_geo._poly[ply].clip(nst_geo,ref_geo,cam);//clip the points and set my nst data with new clipped points								if(new_poly.length>0){									nst_geo._poly[ply]._pointids = new_poly;								}else{									draw_poly=false;								}							}							if (draw_poly) draw_data.push( nst_geo._poly[ply].prep( nst_geo, cam._rm ) );												}											}				}			}			return draw_data;		}		//--------------	}}