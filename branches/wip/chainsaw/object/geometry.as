package chainsaw.object{	import chainsaw.math.vector4;	import chainsaw.math.matrix4;		public class geometry //extends ?	{		public var _numpoints	:	Number 	=	0;		public var _pointlist	:	Array	=	new Array();				public var _numpolys	:	Number	=	0;		public var _poly		:	Array	=	new Array();		public var _polycolor	:	Array	=	new Array();				public var _normallist	:	Array	=	new Array();				public var _rad			:	Number	=	0;		public var _cen			:	vector4 = 	new vector4();				public var _ttm		:		matrix4 = 	new matrix4();		public var _trm		:		matrix4 = 	new matrix4();		public var _rnm		:		matrix4 = 	new matrix4();				public var _intersect :		Number;				//set up the translation matrix? and normal?				public function geometry():void		{					}				public function addpoint(p:Array):void		{			//trace("x:"+p[0]+"	y:"+p[1]+"	z:"+p[2])    		this._pointlist[this._numpoints] = new vector4(p[0], p[1], p[2],1);    		this._numpoints++;		}				public function addpoly(pv:Array,col:String):void		{			this._poly[this._numpolys]=pv;//put all verts for a poly in array			if(pv.length>2){//if this is a more than a line, a real polygon				//trace("x:"+this._pointlist[pv[0]]+"	y:"+this._pointlist[pv[1]]+"	z:"+this._pointlist[pv[2]])				this._normallist[this._numpolys] = new vector4();				this._normallist[this._numpolys].polynormal(this._pointlist[pv[0]], this._pointlist[pv[1]], this._pointlist[pv[2]]);//get normals			}			this._polycolor[this._numpolys] = col;    		this._numpolys++;		}				public function find_bounding_sphere():void		{			var ln:Number = 100000;						var xmin = new vector4(ln,0,0);			var xmax = new vector4(-ln,0,0);			var ymin = new vector4(0,ln,0);			var ymax = new vector4(0,-ln,0);			var zmin = new vector4(0,0,ln);			var zmax = new vector4(0,0,-ln);						for(var i in this._pointlist){//start setting maximum and minmun points				var p = this._pointlist[i];//shorten equation				if (p._x<xmin._x) xmin = p; // New xminimum point 				if (p._x>xmax._x) xmax = p;				if (p._y<ymin._y) ymin = p;				if (p._y>ymax._y) ymax = p;				if (p._z<zmin._z) zmin = p;				if (p._z>zmax._z) zmax = p;			}			// Set xspan = distance between the 2 points xmin & xmax (squared) 			var dx:Number = xmax._x - xmin._x;			var dy:Number = xmax._y - xmin._y;			var dz:Number = xmax._z - xmin._z;			var xspan:Number = dx*dx + dy*dy + dz*dz;						//Same for y & z spans 			dx = ymax._x - ymin._x;			dy = ymax._y - ymin._y;			dz = ymax._z - ymin._z;			var yspan = dx*dx + dy*dy + dz*dz;						dx = zmax._x - zmin._x;			dy = zmax._y - zmin._y;			dz = zmax._z - zmin._z;			var zspan = dx*dx + dy*dy + dz*dz;						// Set points dia1 & dia2 to the maximally seperated pair 			var dia1:vector4 = xmin; 			var dia2:vector4 = xmax; // assume xspan biggest 			var maxspan:Number = xspan;			if (yspan>maxspan){				maxspan = yspan;				dia1 = ymin; 				dia2 = ymax;			}			if (zspan>maxspan){				maxspan = zspan;				dia1 = zmin; 				dia2 = zmax;			}			// dia1,dia2 is a diameter of initial sphere 			// calc initial center 			var cx:Number = (Number(dia1._x)+Number(dia2._x))/2.0;			var cy:Number = (Number(dia1._y)+Number(dia2._y))/2.0;			var cz:Number = (Number(dia1._z)+Number(dia2._z))/2.0;			var cen = new vector4(cx,cy,cz);			//trace(Number(dia1.x)+Number(dia2.x))			// calculate initial radius**2 and radius 			dx = dia2._x-cen._x; // x componant of radius vector 			dy = dia2._y-cen._y; // y componant of radius vector 			dz = dia2._z-cen._z; // z componant of radius vector 			var rad_sq:Number = dx*dx + dy*dy + dz*dz;			var rad:Number = Math.sqrt(rad_sq);			// SECOND PASS: increment current sphere 			this._rad=rad;			this._cen=cen;			//trace(rad+"	cen.x:"+cen.x+"	cen.y:"+cen.y+"	cen.z:"+cen.z)						for(i in this._pointlist){//start setting maximum and minmun points				p=this._pointlist[i];//shorten equation				dx = p._x-cen._x;				dy = p._y-cen._y;				dz = p._z-cen._z;				var old_to_p_sq:Number = dx*dx + dy*dy + dz*dz;				if (old_to_p_sq > rad_sq){ 	// do r**2 test first this point is outside of current sphere 					var old_to_p:Number = Math.sqrt(old_to_p_sq);					// calc radius of new sphere 					rad = (rad + old_to_p) / 2.0;					rad_sq = rad*rad; 	// for next r**2 compare 					var old_to_new:Number = old_to_p - rad;					// calc center of new sphere 					cen._x = (rad*cen._x + old_to_new*p._x) / old_to_p;					cen._y = (rad*cen._y + old_to_new*p._y) / old_to_p;					cen._z = (rad*cen._z + old_to_new*p._z) / old_to_p;					//cen._w = 1;					// Suppress if desired 					this._rad=rad;					this._cen=cen;					//trace(obj.rad+"	cen.x:"+obj.cen.x+"	cen.y:"+obj.cen.y+"	cen.z:"+obj.cen.z)				}				}		}		public function frustum_check(frustum):Number{			var intersect:Number = 1;			for (var plane = 0; plane < 6; plane++ ) {//check against frustum planes to see if object is in viewable area				var dp				= new vector4().d_p4(frustum._normallist[plane], this._cen);//dot product of frustum plane [i] and center of sphere				var r:Number  		= this._rad;//object sphere radius look up once.				if( dp<=r && dp>=-r) intersect=0;//intersecting				if( dp+r < 0 ) intersect=-1;			}			return intersect;		}		//-----------------		//-----------------	}}