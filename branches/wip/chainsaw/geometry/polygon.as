package chainsaw.geometry{		import chainsaw.geometry.geometry;	import chainsaw.math.*;		public class polygon extends vector4	{		public var _polycolor	:	String;				public var _pointids	:	Array;		public var _id			:	Number;		public var _parent_geo	:	geometry;			public var _backface_cull :	Boolean;				public function polygon(g:geometry,pv:Array,col:String,id:Number,bf:Boolean,calc_normal:Boolean=true):void		{			_pointids=pv;			_polycolor = col;			_parent_geo = g;			_id = id;			_backface_cull = bf;						if(pv.length>2)//if this is a more than a line, a real polygon			{				if(calc_normal)				{					normal( g._pointlist[pv[0]], g._pointlist[pv[1]], g._pointlist[pv[2]] );//get normal				}			}		}		public function normal( p1:vector, p2:vector, p3:vector ):void//determine the polygons normal		{			var v1 = new vector( (p1._x - p2._x) , (p1._y - p2._y) , (p1._z - p2._z) );			var v2 = new vector( (p1._x - p3._x) , (p1._y - p3._y) , (p1._z - p3._z) );						var cp = v1.cross(v2);			var norm = cp.normalize();			var d = norm.dot(p1);						_x=norm._x;			_y=norm._y;			_z=norm._z;			_w=d;		}		public function duplicate(p:polygon):void		{			_polycolor	= p._polycolor;					_pointids	= p._pointids;			_id			= p._id;			_parent_geo	= p._parent_geo;				_backface_cull = p._backface_cull;			_x = p._x;			_y = p._y;			_z = p._z;			_w = p._w;		}		//--------------------------------		public function cull(v:vector4 , nmatrix:matrix3 , geo:geometry):Boolean //v is the camera out vector, noemal matri and tranlate matrix		{				var c : Boolean = false;			if(_backface_cull)			{				var d = 1;				if(_pointids.length > 2)				{					var onn = new vector(_x,_y,_z);					onn.multiply_m3(nmatrix) ;//obj.tnm);//get the poly normals					onn = new vector4( onn._x, onn._y, onn._z, onn.dot( geo._pointlist[_pointids[0]] ) );					var ndir = onn.dot( v );					d = ndir-onn._w;				}				c = (d>=0)?false:true;			}			return c;		}		//--------		public function clip(nst,ref,cam):Array		{			var distances = new Array();//array to hold distances			var eop:Number = nst._pointlist.length;//end of poly points			var npp:Number = _pointids.length;			var allin:Boolean = true;			var allout:Boolean = true;			var pp:vector = new vector();			var cv:Array = new Array();						for( var p:Number = 0; p < cam._clip_to.length; p++ ){//for each plane to cut to				for (var i=0; i < npp; i++){//find out if all points in poly are infron or behind plane					distances[i] =  nst._pointlist[ _pointids[i] ].dot(  cam._clip_to[p] ) - cam._clip_to[p]._w;//dot product of frustum plane [i] and center of sphere					if (distances[i]<0) allin = false;					if (distances[i]>=0) allout = false;				}				//-----------------				if (allout){					//new_poly = false;				}else{					if (allin){//no need to continue clipping go with normal prep function						cv=_pointids					}else{						//start clipping						//Sutherland-Hodgeman Clipping						for (i=0; i < npp; i++){							var pd:Number = i+1;							if(i==npp-1) pd = 0;//if this is the last point, set pd to 0							var factor:Number							var inter = new vector();							if (distances[i] >= 0 && distances[pd] >= 0){//both in								cv.push(_pointids[pd]);//push second verts reference.							}else if (distances[i] < 0 && distances[pd] >= 0){//coming in								factor = distances[i]/(distances[i]-distances[pd]);								inter._x = nst._pointlist[ _pointids[i] ]._x + (nst._pointlist[ _pointids[pd] ]._x-nst._pointlist[ _pointids[i] ]._x) * factor;								inter._y = nst._pointlist[ _pointids[i] ]._y + (nst._pointlist[ _pointids[pd] ]._y-nst._pointlist[ _pointids[i] ]._y) * factor;								inter._z = nst._pointlist[ _pointids[i] ]._z + (nst._pointlist[ _pointids[pd] ]._z-nst._pointlist[ _pointids[i] ]._z) * factor;								nst._pointlist[eop] = new vector(inter._x,inter._y,inter._z);																cv.push(eop);								cv.push(_pointids[pd]);								eop++;							}else if (distances[i] >= 0 && distances[pd] < 0){//going out								factor = distances[i]/(distances[i]-distances[pd]);								inter._x = nst._pointlist[ _pointids[i] ]._x + (nst._pointlist[ _pointids[pd] ]._x-nst._pointlist[ _pointids[i] ]._x) * factor;								inter._y = nst._pointlist[ _pointids[i] ]._y + (nst._pointlist[ _pointids[pd] ]._y-nst._pointlist[ _pointids[i] ]._y) * factor;								inter._z = nst._pointlist[ _pointids[i] ]._z + (nst._pointlist[ _pointids[pd] ]._z-nst._pointlist[ _pointids[i] ]._z) * factor;								nst._pointlist[eop] = new vector(inter._x,inter._y,inter._z);									cv.push(eop);								eop++;							}						}						npp = cv.length;					}				}			}			return cv;		}		//--------		public function prep( nst, cam_rndr_matrix):Array		{			var polyinfo = new Array();//create a new array to hold the polys new info for drawing			var polytpoints = new Array();//an array to hold the translated points			var pp:vector4 = new vector4(); 			//var polycolor = getfacecolor(onn,oobj.polycolor[ply]);//get the color of the poly with normal and poly color info			polyinfo.push("nada");						var j:Number=-1;			var zdepth:Number=0;			var drawdepth:Number;			//var npp:Number= nst._poly[_id]._pointids.length;			var npp:Number= _pointids.length;			while(++j < npp){//loop through every point in polygon to draw poly				pp = new vector4( nst._pointlist[ _pointids[j] ]._x,nst._pointlist[ _pointids[j] ]._y,nst._pointlist[ _pointids[j] ]._z);				pp.multiply_m4(cam_rndr_matrix);								var ux = pp._x / pp._w;//was divided by polypoint.w				var uy = pp._y / pp._w;				var uz = pp._z / pp._w;				polytpoints.push( new vector(ux,uy,uz) );				zdepth+=uz;			}						polyinfo.push(polytpoints);//add the translated poly points			//polyinfo.push(drawdepth);//   [ color , [[],[],[]]==points , depth ]			polyinfo.push(9);			return polyinfo;		}		//------	}}