package chainsaw.geometry{		import chainsaw.math.*;	import chainsaw.geometry.polygon;	public class geometry extends vector{		public var _obj		:		Array = new Array();					//array to hold the objects in obj		public var _numpoints	:	Number 	=	0;		public var _pointlist	:	Array	=	new Array();		public var _numpolys	:	Number	=	0;		public var _poly		:	Array	=	new Array();		public var _rad			:	Number	=	0;		public var _cen			:	vector = 	new vector();		public var _ttm		:		matrix4 = 	new matrix4();		public var _trm		:		matrix3 = 	new matrix3();		public var _rnm		:		matrix4 = 	new matrix4();		public var _intersect :		Number;				public var _backface_cull : Boolean = true;						public function geometry():void		{		}				public function addpoint(p:Array):void		{    		_pointlist[_numpoints] = new vector(p[0], p[1], p[2]);    		_numpoints++;		}				public function addpoly(pv:Array,col:String,calc_normal:Boolean=true):void		{			_poly[_numpolys]= new polygon(this,pv,col,_numpolys,_backface_cull,calc_normal);    		this._numpolys++;		}				//===============================		public function rotateX(d:Number):void		{			_trm.rotateX(d);			_rnm.mult_3matrix_4matrix(_trm,_ttm);		}		public function rotateY(d:Number):void		{			_trm.rotateY(d);			_rnm.mult_3matrix_4matrix(_trm,_ttm);		}		public function rotateZ(d:Number):void		{			_trm.rotateZ(d);			_rnm.mult_3matrix_4matrix(_trm,_ttm);		}		//===============================				public function find_bounding_sphere():void		{			var ln:Number = 100000;						var xmin = new vector(ln,0,0);			var xmax = new vector(-ln,0,0);			var ymin = new vector(0,ln,0);			var ymax = new vector(0,-ln,0);			var zmin = new vector(0,0,ln);			var zmax = new vector(0,0,-ln);						for(var i in _pointlist){//start setting maximum and minmun points				var p = _pointlist[i];//shorten equation				if (p._x<xmin._x) xmin = p; // New xminimum point 				if (p._x>xmax._x) xmax = p;				if (p._y<ymin._y) ymin = p;				if (p._y>ymax._y) ymax = p;				if (p._z<zmin._z) zmin = p;				if (p._z>zmax._z) zmax = p;			}			// Set xspan = distance between the 2 points xmin & xmax (squared) 			var dx:Number = xmax._x - xmin._x;			var dy:Number = xmax._y - xmin._y;			var dz:Number = xmax._z - xmin._z;			var xspan:Number = dx*dx + dy*dy + dz*dz;						//Same for y & z spans 			dx = ymax._x - ymin._x;			dy = ymax._y - ymin._y;			dz = ymax._z - ymin._z;			var yspan = dx*dx + dy*dy + dz*dz;						dx = zmax._x - zmin._x;			dy = zmax._y - zmin._y;			dz = zmax._z - zmin._z;			var zspan = dx*dx + dy*dy + dz*dz;						// Set points dia1 & dia2 to the maximally seperated pair 			var dia1:vector = xmin; 			var dia2:vector = xmax; // assume xspan biggest 			var maxspan:Number = xspan;			if (yspan>maxspan){				maxspan = yspan;				dia1 = ymin; 				dia2 = ymax;			}			if (zspan>maxspan){				maxspan = zspan;				dia1 = zmin; 				dia2 = zmax;			}			// dia1,dia2 is a diameter of initial sphere 			// calc initial center 			var cx:Number = (Number(dia1._x)+Number(dia2._x))/2.0;			var cy:Number = (Number(dia1._y)+Number(dia2._y))/2.0;			var cz:Number = (Number(dia1._z)+Number(dia2._z))/2.0;			var cen = new vector(cx,cy,cz);			//trace(Number(dia1.x)+Number(dia2.x))			// calculate initial radius**2 and radius 			dx = dia2._x-cen._x; // x componant of radius vector 			dy = dia2._y-cen._y; // y componant of radius vector 			dz = dia2._z-cen._z; // z componant of radius vector 			var rad_sq:Number = dx*dx + dy*dy + dz*dz;			var rad:Number = Math.sqrt(rad_sq);			// SECOND PASS: increment current sphere 			this._rad=rad;			this._cen=cen;			//trace(rad+"	cen.x:"+cen.x+"	cen.y:"+cen.y+"	cen.z:"+cen.z)						for(i in this._pointlist){//start setting maximum and minmun points				p=this._pointlist[i];//shorten equation				dx = p._x-cen._x;				dy = p._y-cen._y;				dz = p._z-cen._z;				var old_to_p_sq:Number = dx*dx + dy*dy + dz*dz;				if (old_to_p_sq > rad_sq){ 	// do r**2 test first this point is outside of current sphere 					var old_to_p:Number = Math.sqrt(old_to_p_sq);					// calc radius of new sphere 					rad = (rad + old_to_p) / 2.0;					rad_sq = rad*rad; 	// for next r**2 compare 					var old_to_new:Number = old_to_p - rad;					// calc center of new sphere 					cen._x = (rad*cen._x + old_to_new*p._x) / old_to_p;					cen._y = (rad*cen._y + old_to_new*p._y) / old_to_p;					cen._z = (rad*cen._z + old_to_new*p._z) / old_to_p;					//cen._w = 1;					// Suppress if desired 					this._rad=rad;					this._cen=cen;					//trace(obj.rad+"	cen.x:"+obj.cen.x+"	cen.y:"+obj.cen.y+"	cen.z:"+obj.cen.z)				}				}		}	}}