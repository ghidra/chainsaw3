package chainsaw{	import flash.display.Shape;	import flash.display.Sprite;	import flash.utils.getTimer;	import flash.text.TextField;    import flash.text.TextFormat;    import flash.text.TextFieldAutoSize;		import chainsaw.camera;	import chainsaw.scene;	import chainsaw.vector4;	import chainsaw.matrix4;	import chainsaw.obj;	import chainsaw.obj_instance;	import chainsaw.geometry;		public class renderer extends Sprite	{		//drawing vars		private var _drawarray : Array = new Array();		private var _camtoface = new vector4(0,0,-1,0);//var camtoface = new vector(cam1.rnm[3],cam1.rnm[7],cam1.rnm[11],cam1.rnm[15]) ; var camtoface = new vector4(cam1.rnm[8],cam1.rnm[9],cam1.rnm[10],cam1.rnm[15]);		private var _scene	:	scene;		private var _camera	:	camera;		private var _screen :	Shape = new Shape();				//user views		public var _fps:Boolean=false;		public var _map:Boolean=false;				private var fps_text:TextField;		private var time :Number;		private var frameTime :Number;		private var prevFrameTime :Number = getTimer();		private var secondTime :Number;		private var prevSecondTime :Number = getTimer();		private var frames :Number = 0;		private var fps :String = "";	 	private var format:TextFormat = new TextFormat();				public function renderer(scn:scene,cam:camera):void		{			_scene = scn;//pass in the scene			_camera = cam;//psdd the camera					addChild(_screen);//add the screen to the stage		}				public function renderscene():void{			_drawarray = new Array();//this._drawarray.length=100000;						for(var i in _scene._scene){//for eash object in array of objects								var nstance	:	obj_instance	=	_scene._scene[i];//the instance to object				var nst_arr	:	Array 			= 	nstance._obj;//the array of objects								var ref_num	:	Number 			= 	_scene._scene[i]._pointer;//the reference number to object				var ref_arr	:	Array 			= 	_scene._objects[ref_num]._obj;//the array of objects				for(var obj in nst_arr){//for each peice of geomoetry in obj								var nst_geo	:	geometry	=	nst_arr[obj];//the instanced geometry					var ref_geo	:	geometry 	= 	ref_arr[obj];//the or object geometry					var newttm 					= 	new matrix4();					nst_geo._pointlist 			= 	new Array();//empty array					nst_geo._cen 				= 	new vector4();					newttm.tform_4matrix( nstance._rnm, _camera._rnm );//multiply camera into transforms					nst_geo._cen.mult_v_m4( ref_geo._cen, newttm );//translate center vert										nst_geo._intersect = frustum_check( nst_geo );										if(nst_geo._intersect >= 0){//if the object is inside the frustum						var newtnm = new matrix4();						var newnew = new matrix4();												newtnm.tform_4matrix( nstance._trm, _camera._trm );//multiply camera into normals transforms						newnew.mult_4matrix( newttm, _camera._rm );//multiply by render matrix												for (var ply in ref_geo._poly){//go through the polygons														var facedirection:Number = (ref_geo._poly[ply].length > 2) ? facedirection_check( ref_geo._normallist[ply], newtnm, ref_geo._pointlist[ ref_geo._poly[ply][0] ], newttm ) : 1;//if there are more than 2 points to a poly get face direction, otherwise face direction is 1							if( facedirection  >= 0 ){								//if(nst_geo._intersect==0) clip_poly(ref_geo._poly[ply], nst_geo, ref_geo, newttm);								prep_poly( ref_geo._poly[ply], nst_geo, ref_geo, newttm, newnew);//prep polygon to be drawn							}						}					}				}			}						draw_scene();			if(_fps==true) calc_fps();		}				private function frustum_check(geo):Number{			var intersect:Number = 1;			for (var plane = 0; plane < 6; plane++ ) {//check against frustum planes to see if object is in viewable area				var dp				= new vector4().d_p4(_camera._obj[0]._normallist[plane], geo._cen);//dot product of frustum plane [i] and center of sphere				var r:Number  		= geo._rad;//object sphere radius look up once.				if( dp<=r && dp>=-r) intersect=0;//intersecting				if( dp+r < 0 ) intersect=-1;			}			return intersect;		}		private function facedirection_check(normal,nmatrix,point,tmatrix):Number{			var onn = new vector4();			var transnorm = new vector4();			var ndir:Number;										onn.mult_v_m4(normal,nmatrix) ;//obj.tnm);//get the poly normals			transnorm.mult_v_m4(point,tmatrix);			onn._w = new vector4().d_p(onn,transnorm);//go ahead and make it a 4 point vecotr, 0 for direction vector.			ndir = new vector4().d_p( onn,this._camtoface);			return ndir-onn._w;		}		private function prep_poly(polyarray, nst, ref, transmatrix, drawmatrix):void{				var poly:Array = polyarray;			var polyinfo = new Array();//create a new array to hold the polys new info for drawing			var polytpoints = new Array();//an array to hold the translated points			var pp:vector4 = new vector4(); 			//var polycolor = getfacecolor(onn,oobj.polycolor[ply]);//get the color of the poly with normal and poly color info			//polyinfo.push(polycolor);//add the poly color to the poly info			polyinfo.push("nada");						var j:Number=-1;			var k:Number=-1;			var l:Number=-1;			var zdepth:Number=0;			var drawdepth:Number;			var npp:Number= poly.length;						if( nst._intersect < 1 ){//is this polygon is from an intersecting object				//trace(nst._intersect);				var clipto:Array = [ _camera._obj[0]._normallist[0] ];//clip to array right now clip to near plane, later far plane, then maybe all				var distances = new Array();//array to hold distances				var eop:Number = ref._pointlist.length;//end of poly points				var allin:Boolean = true;				var allout:Boolean = true;								for( var p:Number = 0; p < clipto.length; p++ ){//for each plane to cut to										for (var i=0; i < npp; i++){//find out if all points in poly are infron or behind plane						//if(!nst._pointlist[ poly[i] ]){//translate point if it hasn't been translated. only translates visible points.							nst._pointlist[ poly[i] ] = new vector4();							nst._pointlist[ poly[i] ].mult_v_m4(ref._pointlist[ poly[i] ], transmatrix);						//}						pp = nst._pointlist[ poly[i] ];//polypoint 						distances[i] =  new vector4().d_p( pp, clipto[p]) - clipto[p]._w;//dot product of frustum plane [i] and center of sphere						if (distances[i]<0) allin = false;						if (distances[i]>=0) allout = false;					}					//-----------------					if (allout){						npp=0;						break;//npp=0;//create no polygon, no need to continue don't even prep poly					}					if (allin){//no need to continue clipping go with normal prep function						for (var ep=0; ep < npp; ep++){							nst._pointlist[ poly[ep] ] = undefined;//set polys back for transoforming						}					}else{						//-----------------						//start clipping						//Sutherland-Hodgeman Clipping						var cv = new Array();//new clipped verts array						for (i=0; i < npp; i++){							var pd:Number = i+1;							if(i==npp-1) pd = 0;//if this is the last point, set pd to 0												var factor:Number							var inter = new vector4();							//trace(nst._pointlist[ poly[pd] ]);							if (distances[i] >= 0 && distances[pd] >= 0){//both in								cv.push(poly[pd]);//push second verts reference.							}else if (distances[i] < 0 && distances[pd] >= 0){//coming in								factor = distances[i]/(distances[i]-distances[pd]);														inter._x = nst._pointlist[ poly[i] ]._x + (nst._pointlist[ poly[pd] ]._x-nst._pointlist[ poly[i] ]._x) * factor;								inter._y = nst._pointlist[ poly[i] ]._y + (nst._pointlist[ poly[pd] ]._y-nst._pointlist[ poly[i] ]._y) * factor;								inter._z = nst._pointlist[ poly[i] ]._z + (nst._pointlist[ poly[pd] ]._z-nst._pointlist[ poly[i] ]._z) * factor;								//inter.mult_v_m4(inter, _camera._rm);								nst._pointlist[eop] = new vector4();								nst._pointlist[eop].mult_v_m4(inter, _camera._rm);								//trace(_camera._rm)																cv.push(eop);								cv.push(poly[pd]);								eop++;							}else if (distances[i] >= 0 && distances[pd] < 0){//going out								factor = distances[i]/(distances[i]-distances[pd]);														inter._x = nst._pointlist[ poly[i] ]._x + (nst._pointlist[ poly[pd] ]._x-nst._pointlist[ poly[i] ]._x) * factor;								inter._y = nst._pointlist[ poly[i] ]._y + (nst._pointlist[ poly[pd] ]._y-nst._pointlist[ poly[i] ]._y) * factor;								inter._z = nst._pointlist[ poly[i] ]._z + (nst._pointlist[ poly[pd] ]._z-nst._pointlist[ poly[i] ]._z) * factor;								//inter.mult_v_m4(inter, _camera._rm);								nst._pointlist[eop] = new vector4();								nst._pointlist[eop].mult_v_m4(inter, _camera._rm);																cv.push(eop);								eop++;							}						}											for (i=0; i < npp; i++){//erase math							nst._pointlist[ poly[i] ] = undefined;//set polys back for transoforming						}						poly = cv;						npp = cv.length;					}				}			}							while(++j < npp){//loop through every point in polygon to draw poly				//trace(j+"	"+ ref_geo._poly[ply].length)								if(!nst._pointlist[ poly[j] ]){//translate point if it hasn't been translated. only translates visible points.					nst._pointlist[ poly[j] ] = new vector4();					nst._pointlist[ poly[j] ].mult_v_m4(ref._pointlist[ poly[j] ], drawmatrix);				}				pp = nst._pointlist[ poly[j] ];//polypoint 								var ux = pp._x / pp._w;//was divided by polypoint.w				var uy = pp._y / pp._w;				var uz = pp._z / pp._w;				//trace("x:"+x+"	y:"+y+"	z:"+z);				polytpoints.push( new vector4(ux,uy,uz) );				zdepth+=uz;			}						if(npp){				drawdepth = Math.ceil(100000 - ((zdepth*100000)/npp));//get drawdepth: divide added up z value from camera by number of points in polygon				polyinfo.push(polytpoints);//add the translated poly points				polyinfo.push(drawdepth);//   [ color , [[],[],[]]==points , depth ]								while(this._drawarray[drawdepth]){//this while  loop works for putting polys at the same depth in the array					drawdepth++;				}				this._drawarray[drawdepth]=polyinfo;//put the poly info in the draw array			}		}		private function draw_scene():void{			this._screen.graphics.clear();			//trace("*************************");			for(var a in this._drawarray){//go through array start from 0				//trace(this._drawarray[a][2])				//this._drawarray.sort();				if(this._drawarray[a]){//if there is a polygon in alotted spot draw it					//this._screen.graphics.beginFill(this._drawarray[a][0],100);					//this._screen.graphics.beginFill(0xFF,100);					this._screen.graphics.lineStyle(1, 0x000000, 100);					var p:Number=-1;					while(++p < this._drawarray[a][1].length){						if(p==0){							//trace("move to x:"+this._drawarray[a][1][0]._x+"	y:"+this._drawarray[a][1][0]._y);							var endx:Number = this._drawarray[a][1][0]._x;							var endy:Number = this._drawarray[a][1][0]._y;							this._screen.graphics.moveTo(endx,endy);						}else{							//trace("draw to x:"+this._drawarray[a][1][p]._x+"	y:"+this._drawarray[a][1][p]._y);							this._screen.graphics.lineTo(this._drawarray[a][1][p]._x,this._drawarray[a][1][p]._y);						}						//trace(p);;					}					this._screen.graphics.lineTo(endx,endy);					//this._screen.graphics.endFill();				}			}		}		//------------------		//------------------		//-fps		/*		http://code.google.com/p/squidder/		*/		public function toggle_fps():void{			if(this._fps==false){				this._fps=true;				fps_text = new TextField();				this.addChild(fps_text);								this.format.font = "Verdana";				this.format.color = 0x000000;				this.format.size = 10;				fps_text.autoSize = TextFieldAutoSize.LEFT;				fps_text.defaultTextFormat = format;				fps_text.text = "-- FPS ---- AV";							}else{				//need to delete the fps window				this._fps=false;			}		}		private function calc_fps():void{						time = getTimer();			frameTime = time - prevFrameTime;			secondTime = time - prevSecondTime;						if(secondTime >= 1000) {				fps = frames.toString();				frames = 0;				prevSecondTime = time;			}else{				frames++;			}						prevFrameTime = time;			fps_text.text = ((fps + " FPS / ") + frameTime) + " MS" ;			//iBar.scaleX = iBar.scaleX - ((iBar.scaleX - (frameTime /10)) / 5);		}				public function toggle_map():void{			if(this._map==false){				this._map=true;			}else{				this._map=false;			}		}		//------------------		//------------------	}}